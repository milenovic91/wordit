package com.geniye.wordit.web;

import com.fasterxml.jackson.annotation.JsonRootName;
import com.geniye.wordit.core.TokenService;
import com.geniye.wordit.core.dto.UserDTO;
import com.geniye.wordit.core.models.User;
import com.geniye.wordit.db.UserRepository;
import lombok.Getter;
import lombok.NoArgsConstructor;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.ResponseEntity;
import org.springframework.security.core.annotation.AuthenticationPrincipal;
import org.springframework.validation.BindingResult;
import org.springframework.web.bind.annotation.*;

import javax.validation.Valid;
import javax.validation.constraints.Email;
import javax.validation.constraints.NotBlank;
import java.util.HashMap;
import java.util.Optional;

@RestController
public class UsersController {
  private UserRepository userRepository;
  private TokenService tokenService;

  @Autowired
  public void UsersController(UserRepository userRepository,
                              TokenService tokenService) {
    this.userRepository = userRepository;
    this.tokenService = tokenService;
  }

  @RequestMapping(path = "/users", method = RequestMethod.POST)
  public ResponseEntity createUser(@Valid @RequestBody CreateUserBody body, BindingResult bindingResult) {
    if (bindingResult.hasErrors()) {
      throw new RuntimeException(bindingResult.toString());
    }
    /**
     * TODO - validate email/username is not taken. Currently it's handled on db level with constraints.
     * Possible drawback? - it increments autogenerated id even if save fails.
     * Also, even User's id on the following line is set to 0 it's going to be updated by mybatis.
     * That only works if useGeneratedKeys+keyProperty are used.
     */
    User user = new User(0, body.username, body.password, body.email, null, null);
    this.userRepository.save(user);
    return ResponseEntity.status(200).body(this.userResponse(user, null));
  }

  @RequestMapping(path = "users/login", method = RequestMethod.POST)
  public ResponseEntity loginUser(@Valid @RequestBody LoginUserBody body, BindingResult bindingResult) {
    if (bindingResult.hasErrors()) {
      throw new RuntimeException(bindingResult.toString());
    }
    Optional<User> user = userRepository.findByEmail(body.email);
    if (user.isPresent()) {
      if (!user.get().getPassword().equals(body.password)) {
        throw new RuntimeException("Username and password do not match");
      }
      return ResponseEntity.status(200).body(this.userResponse(user.get(), null));
    }
    throw new RuntimeException("Username and password do not match");
  }

  @RequestMapping(path = "/user", method = RequestMethod.GET)
  public ResponseEntity currentUser(@AuthenticationPrincipal User user) {
    return ResponseEntity.ok(this.userResponse(user, null));
  }

  @RequestMapping(path = "/user", method = RequestMethod.PUT)
  public ResponseEntity updateCurrentUser(@Valid @RequestBody UpdateUserBody body, @AuthenticationPrincipal User user) {
    user.update(body.getEmail(), body.getPassword(), body.getBio(), body.getImage());
    this.userRepository.update(user);
    return ResponseEntity.status(200).body(this.userResponse(user, null));
  }

  private HashMap<String, UserDTO> userResponse(User user, String token) {
    UserDTO userDTO = new UserDTO(user);
    if (token == null) {
      userDTO.setToken(this.tokenService.generateToken(user));
    }
    return new HashMap<String, UserDTO>() {{
      put("user", userDTO);
    }};
  }
}

@JsonRootName("user")
class CreateUserBody {
  @NotBlank
  @Email
  public String email;
  @NotBlank
  public String username;
  @NotBlank
  public String password;
}

@JsonRootName("user")
class LoginUserBody {
  @NotBlank
  @Email
  public String email;
  @NotBlank
  public String password;
}

@Getter
@JsonRootName("user")
@NoArgsConstructor
class UpdateUserBody {
  @Email(message = "should be an email")
  private String email = "";
  private String password = "";
  private String bio = "";
  private String image = "";
}
