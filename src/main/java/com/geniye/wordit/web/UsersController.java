package com.geniye.wordit.web;

import com.fasterxml.jackson.annotation.JsonRootName;
import com.geniye.wordit.core.TokenService;
import com.geniye.wordit.core.dto.UserDTO;
import com.geniye.wordit.core.models.User;
import com.geniye.wordit.db.UserRepository;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.ResponseEntity;
import org.springframework.validation.BindingResult;
import org.springframework.web.bind.annotation.*;

import javax.validation.Valid;
import javax.validation.constraints.Email;
import javax.validation.constraints.NotBlank;
import java.util.HashMap;
import java.util.Optional;

@RestController
@RequestMapping(value = "/users")
public class UsersController {
  private UserRepository userRepository;
  private TokenService tokenService;

  @Autowired
  public void UsersController(UserRepository userRepository,
                              TokenService tokenService) {
    this.userRepository = userRepository;
    this.tokenService = tokenService;
  }

  @RequestMapping(method = RequestMethod.POST)
  public ResponseEntity createUser(@Valid @RequestBody CreateUserBody body, BindingResult bindingResult) {
    if (bindingResult.hasErrors()) {
      throw new RuntimeException(bindingResult.toString());
    }
    /**
     * TODO - validate email/username is not taken. Currently it's handled on db level with constraints.
     * Possible drawback? - it increments autogenerated id even if save fails.
     * Also, even User's id on the following line is set to 0 it's going to be updated by mybatis.
     */
    User user = new User(0, body.username, body.password, body.email, null, null);
    this.userRepository.save(user);
    return ResponseEntity.status(200).body(this.userResponse(user));
  }

  @RequestMapping(path = "/login", method = RequestMethod.POST)
  public ResponseEntity loginUser(@Valid @RequestBody LoginUserBody body, BindingResult bindingResult) {
    if (bindingResult.hasErrors()) {
      throw new RuntimeException(bindingResult.toString());
    }
    Optional<User> user = userRepository.findByEmail(body.email);
    if (user.isPresent()) {
      if (!user.get().getPassword().equals(body.password)) {
        throw new RuntimeException("Username and password do not match");
      }
      return ResponseEntity.status(200).body(this.userResponse(user.get()));
    }
    throw new RuntimeException("Username and password do not match");
  }

  private HashMap<String, UserDTO> userResponse(User user) {
    UserDTO userDTO = new UserDTO(user);
    userDTO.setToken(this.tokenService.generateToken(user));
    return new HashMap<String, UserDTO>() {{
      put("user", userDTO);
    }};
  }
}

@JsonRootName("user")
class CreateUserBody {
  @NotBlank
  @Email
  public String email;
  @NotBlank
  public String username;
  @NotBlank
  public String password;
}

@JsonRootName("user")
class LoginUserBody {
  @NotBlank
  @Email
  public String email;
  @NotBlank
  public String password;
}